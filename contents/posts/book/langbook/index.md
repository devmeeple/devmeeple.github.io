---
title: "코딩을 지탱하는 기술"
description: ""
date: 2025-05-19 20:40:00
update: 2025-05-19 20:40:00
tags:
  - 독서
series: 
---

![『코딩을 지탱하는 기술』(니시오 히로카즈, 비제이퍼블릭, 2013)](9788994774480.jpg)

## 후기

- 프로그래밍 언어에서 공통적으로 사용되는 문법의 발전과정을 파악할 수 있다. 역사책 같다.
- 정리와 저자의 조언이 인상 깊다. (학습법)
- 가볍게 읽기 좋다.
- 일부 번역이 자연스럽지 않다. (총칭형)
- 프로그래밍 언어는 '왜' 그럴까? 고민한 적 있다면 추천한다.

## 1장. 효율적으로 언어 배우기

- 다수의 언어 비교와 언어의 역사를 통해 학습하는 방법을 추천한다. 하지만 가장 중요한 점은 '목적'이다. 목적이 명확해야 학습 효율이 증가한다.

## 2장. 프로그래밍 언어를 조감하다

- 현재 대세의 기술도 과거에는 존재하지 않았다. 선배 개발자의 시점에서 생각하는 방법은 새로운 기술을 학습할 때 유리하다.
- 프로그래밍 언어는 편리한 삶을 위해 등장했다. 하지만 언어마다 추구하는 '편리함'이 다르다. 따라서 설계자의 의도를 파악해야 한다.
    - Java는 'WORA(Write Once, Run Anywhere)'[^1]를 추구한다.

## 3장. 문법의 탄생

- 문법이란 언어 설계자가 정한 규칙이다.
- 현재 어려운 문법이 남아있는 주된 이유 중 하나는 기준 문법과 마찰을 피하고 호환성을 유지하기 위해서다.

## 4장. 처리 흐름 제어

- 제어문, 반복문을 사용하지 않고 코드를 작성할 수 있지만 이해하기 쉬운 코드를 위해 문법이 등장했다.

## 5장. 함수

- 함수란 코드의 일부를 잘라내어 이름을 붙이는 기능이다. 반복해서 사용하는 명령을 재사용하는데 적합하고, 구조를 파악할 때 편리하다.
- 재귀 호출을 사용하면 내포된 리스트, 배열은 다루기 용이하다.

## 6장. 에러 처리

- **실패를 전달하는 방법**
    - 반환값
    - 예외 던지기

## 7장. 이름과 스코프

- 스코프(Scope)란 유효 범위다. 프로그램 전체에서 이름이 충돌하지 않도록 돕는다.

## 8장. 형

- **비트열은 해석 방법에 따라 전혀 다른 값이 된다. '어떤 종류의 값'인지 의미를 표현하기 위해 타입을 도입했다.**
- 타입 시스템은 단순한 타입 정의에서 동적 타입, 사용자 정의 타입, 객체 지향, 제네릭, 타입 추론등 다양한 방향으로 발전했다.
- 동적 타입 언어는 런타임에서 타입을 판별하기 때문에 타입 선언이 필요하지 않다. 대신 언어마다 공통된 인터페이스[^1]를 제공하여 메모리 상에서 다양한 타입을 일관된 방식으로 처리한다.

## 9장. 컨테이너와 문자열

- **자료구조**
    - 배열(Array): 정수와 값을 대응
    - 해쉬(Hash): 키와 값을 대응, 키는 모든 타입의 객체가 될 수 있음
- 자료구조는 정답이 없다. 자신의 상황에 맞춰 선택하는 것이 최선이다.
- 문자는 모스 부호, 아스키(ASCII), EBCDIC 같은 초기 문자 인코딩을 거쳐 현재는 유니코드(Unicode)가 전 세계의 모든 문자를 표현하는 표준으로 정의했다.

## 10장. 병행 처리

- 병행 처리[^2]를 위해 프로세스(Process), 스레드(Thread) 등의 개념이 등장했다. 또한 병행 처리에서 발생하는 문제를 해결하기 위해 락(Lock), 파이버(Fiber) 등의 개념이 등장했다.
- **병행 처리를 해결하는 방법**
    - 협력적 멀티태스킹(Cooperative Multitasking): 최적의 시점을 기다려 교대(협력), 초기 Mac OS 9 이전
    - 선점적 멀티태스킹(Preemptive Multitasking): 일정 시간에 맞춰 교대(강제), 스케줄러가 따로 존재, 현대의 운영체제
- **경합 상태(Race Condition) 방지법**
    - 불변(Immutable) 디자인 패턴
    - 협력적 스레드 사용[^3]: 파이버(Fiber), 코루틴(Coroutine), 그린 스레드(Green Thread)[^4]
    - 사용 중 표시: 락(Lock)[^5]

## 11장. 객체와 클래스

- 객체 지향은 현실 세계의 사물(Object)을 컴퓨터 안의 모델(Model)로 구현한 방법이다.
- Java는 클래스를 설계하고 조립하는 프로그래밍 언어다.
- 패키지(Package)는 관련 있는 함수, 변수를 묶음으로 표현하기 위해 도입했다.
    - Python과 Ruby는 모듈(Module)이라 한다.
- 생성자(Constructor)는 객체를 만드는 함수다.
- 일급 시민(First-Class Citizen)이란 변수에 할당할 수 있고, 함수의 인자로 전달하거나 반환값으로 쓸 수 있는 값을 의미한다.
- 클래스의 시작은 '분류'다.

## 12장. 상속을 통한 재사용

- **상속**
    - 일반적인 기능은 부모 클래스에, 특화된 기능은 자식 클래스에 구현
    - 공통적인 부분을 추출
- 상속을 사용하면 코드 재사용성을 높인다. 하지만 무분별하게 사용하면 코드 영향 범위를 넓혀 주의가 필요하다.

```java
interface Engine {
    void run();
}

class Car {
    private Engine engine;

    // 의존성 주입(생성자 주입)
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void start() {
        engine.run();
    }
}

Engine hondaEngine = new HondaEngine();
Car car = new Car(hondaEngine);
```

- 다중 상속에서 발생하는 다이아몬드 문제[^6]를 해결하기 위해 언어마다 다른 방법을 채택했다.
    - Java에서는 다중 상속을 허용하지 않는다. 대신하여 위임(Delegation)을 사용한다. 위임을 효과적으로 사용하기 위해 의존성 주입(Dependency Injection)을 활용한다.
    - C++의 가상 상속(Virtual Inheritance), Python의 C3 선형화(C3 Linearization), Ruby의 믹스인(Mix-in)

[^1]: 운영체제(OS)와 하드웨어에 종속되지 않고, 한 번 작성한 코드를 어디서든 실행한다.
[^2]: Python의 PyObject, Ruby의 VALUE, JavaScript의 tagged pointer, Nan boxing
[^3]: 프로그램이 계속 동작하고 있는 것처럼 보이지만, 실제로는 잘게 분할해서 실행된다.
[^4]: 여러 작업이 서로 협력하여 실행 흐름을 제어하는 방식
[^5]: 운영체제가 아닌, 런타임 환경(JVM)이 관리하는 스레드
[^6]: 락은 교착 상태(Deadlock)가 발생하는 문제가 있다. 따라서 신중하게 결정해야 한다.
[^7]: 다중 상속 시 공통 조상 클래스에서 상속된 멤버(특히 메서드)가 어떻게 실행되어야 하는지 모호해지는 현상